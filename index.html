<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
  <title>Test Autocomplete</title>
  <style>
    :root {
      /* Palette */
      --ice-cold: #a0d2eb;
      --freeze-purple: #e5eaf5;
      --medium-purple: #d0bdf4;
      --purple-pain: #8458B3;
      --heavy-purple: #a28089;

      /* Mapped theme tokens */
      --bg: var(--freeze-purple);
      --panel: #ffffff;
      --muted: #6b6d83; /* slightly desaturated purple-gray */
      --text: #22223b;
      --border: #dcdff0;
      --accent: var(--purple-pain);
      --accent-2: var(--medium-purple);
      --shadow: 0 6px 16px rgba(0,0,0,.12);
    }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji"; padding: 28px; background: var(--bg); color: var(--text); }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji"; padding: 28px; background: var(--bg); color: var(--text); }
    .wrap { max-width: 980px; margin: 0 auto; }
    .header-row { display:flex; align-items:center; justify-content: space-between; gap: 8px; margin-bottom: 10px; }
    .linklike { background: transparent; border: none; color: var(--muted); cursor: pointer; text-decoration: underline; padding: 4px 6px; border-radius: 6px; }
    .linklike { background: transparent; border: none; color: var(--muted); cursor: pointer; text-decoration: underline; padding: 4px 6px; border-radius: 6px; }
    .linklike:hover { color: var(--text); background: rgba(0,0,0,.03); }
    input[type="text"] { width: 100%; padding: 12px 14px; border: 1px solid var(--border); border-radius: 10px; font-size: 15px; background: var(--panel); color: var(--text); outline: none; }
    input[type="text"]::placeholder { color: #94a3b8; }
    select { padding: 10px 12px; border-radius: 10px; background: var(--panel); color: var(--text); border: 1px solid var(--border); }
    button { padding: 8px 12px; border-radius: 10px; border: 1px solid var(--border); background: #ffffff; color: var(--text); cursor: pointer; }
    button:hover { background: #f3f4f6; }
  /* Bootstrap buttons themed with palette */
  .btn-primary { background-color: var(--purple-pain); border-color: var(--purple-pain); }
  .btn-primary:hover, .btn-primary:focus { background-color: #734aa1; border-color: #734aa1; }
  .btn-outline-secondary { color: var(--purple-pain); border-color: var(--medium-purple); }
  .btn-outline-secondary:hover, .btn-outline-secondary:focus { background-color: var(--medium-purple); color: #fff; border-color: var(--medium-purple); }
  .q-wrap { position: relative; }
  .list { position: absolute; top: calc(100% + 6px); left: 0; right: 0; background: #ffffff; border: 1px solid var(--border); border-radius: 10px; box-shadow: var(--shadow); overflow: hidden; max-height: 360px; overflow-y: auto; z-index: 1040; }
    .item { display: flex; align-items: center; gap: 8px; padding: 10px 12px; cursor: pointer; color: var(--text); }
    .item + .item { border-top: 1px solid var(--border); }
    .item:hover, .item.active { background: rgba(132, 88, 179, .08); /* accent tint */ box-shadow: inset 3px 0 0 var(--accent-2); }
    .item span { flex: 1; min-width: 0; }
    .item strong { color: var(--purple-pain); }
    .badge { font-size: 11px; border: 1px solid var(--border); color: var(--muted); padding: 2px 6px; border-radius: 999px; background: #fff; }
    /* Responsive input grids */
    .inputs-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
  .query-grid { display: grid; grid-template-columns: 1fr auto; gap: 8px; }
    #results .card { border: 1px solid var(--border); border-radius: var(--radius); background: #fff; box-shadow: var(--shadow); }
    @media (max-width: 720px) {
      .inputs-grid, .query-grid { grid-template-columns: 1fr; }
    }
    .hint { color: var(--muted); font-size: 13px; margin-top: 10px; }
    #results .card { border: 1px solid var(--border); border-radius: var(--radius); background: var(--panel); box-shadow: var(--shadow); }

    /* Modal */
  /* Custom modal (namespaced to avoid Bootstrap conflicts) */
  .ai-modal-backdrop { position: fixed; inset: 0; background: rgba(0, 0, 0, .35); display: none; align-items: center; justify-content: center; z-index: 1055; }
  .ai-modal { width: min(880px, 92vw); max-height: min(80vh, 980px); overflow: auto; background: #fff; border: 1px solid var(--border); border-radius: 12px; box-shadow: var(--shadow); }
  .ai-modal header { display:flex; align-items:center; justify-content: space-between; padding: 14px 16px; border-bottom: 1px solid var(--border); position: sticky; top: 0; background: linear-gradient(180deg, #fff, rgba(255,255,255,.9)); }
  .ai-modal header h3 { margin: 0; font-size: 16px; color: var(--text); }
  .ai-modal header .close { border: none; background: transparent; color: var(--muted); font-size: 20px; line-height: 1; padding: 4px 8px; cursor: pointer; }
  .ai-modal header .close:hover { color: var(--text); background: rgba(0,0,0,.05); border-radius: 8px; }
  .ai-modal .content { padding: 14px 16px 18px; }
  .ai-modal .content h4 { margin: 14px 0 6px; font-size: 14px; color: var(--purple-pain); }
  .ai-modal .content p, .ai-modal .content li { color: #424a60; font-size: 14px; line-height: 1.6; }
  .ai-modal .content code, .ai-modal .content kbd { background: var(--freeze-purple); border: 1px solid var(--border); padding: 0 6px; border-radius: 6px; }

  /* Results styling */
  #results { display: grid; grid-template-columns: 1fr; gap: 10px; }
  @media (min-width: 900px) { #results { grid-template-columns: 1fr 1fr; } }
  .result-card { border: 1px solid var(--border); border-radius: 12px; background: var(--panel); box-shadow: var(--shadow); padding: 12px 14px; transition: border-color .2s, transform .06s ease-in-out; }
  .result-card:hover { border-color: var(--accent-2); transform: translateY(-1px); }
  .result-content { display: flex; gap: 12px; align-items: flex-start; }
  .result-img { width: 64px; height: 64px; object-fit: cover; border-radius: 8px; border: 1px solid var(--border); background: var(--freeze-purple); flex-shrink: 0; }
  .result-title { font-weight: 600; color: var(--text); overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; line-clamp: 2; -webkit-box-orient: vertical; }
  .result-meta { color: var(--muted); font-size: 13px; margin-top: 2px; }
  .result-price { color: var(--purple-pain); font-weight: 600; margin-top: 6px; }
  /* Autocomplete highlight styles */
  .suggest-frag { font-weight: 400; }
  .suggest-hit { font-weight: 700; }

    /* Two-column layout */
    .layout { display:flex; gap:26px; align-items:flex-start; }
    /* Make main column a bit narrower to give admin more space */
    .main-col { flex: 0 1 58%; min-width:0; }
    .admin-col { flex: 0 0 42%; max-width:520px; background: var(--panel); border:1px solid var(--border); padding:16px 18px 20px; border-radius:14px; box-shadow: var(--shadow); position:sticky; top:16px; transition: background .25s, color .25s; }
    /* Scrollable phrase list container */
    .admin-col #cp_list { max-height: 380px; overflow:auto; scrollbar-width: thin; }
    .admin-col #cp_list::-webkit-scrollbar { width:8px; }
    .admin-col #cp_list::-webkit-scrollbar-thumb { background: #c9c9d4; border-radius:5px; }
    .admin-col #cp_list::-webkit-scrollbar-track { background: transparent; }
    /* Collapsed state for mobile (will be toggled via class) */
    .admin-col.collapsed { display:none; }
    .admin-col h3 { margin-top:0; }
    @media (max-width: 1000px) {
      .layout { flex-direction: column; }
      .main-col { flex:1 1 auto; }
      .admin-col { flex:1 1 auto; width:auto; position:static; }
    }
    /* Dark mode base (will toggle a body class) */
    body.dark {
      --bg: #1f2330;
      --panel: #272c3a;
      --text: #e6e9f2;
      --border: #384154;
      --muted: #9aa3b5;
      --accent: #b18cff;
      --accent-2: #8e76d9;
      color: var(--text);
      background: var(--bg);
    }
    body.dark .result-card { background: var(--panel); }
    body.dark .admin-col { background: var(--panel); }
    body.dark input, body.dark select, body.dark button { background: #2f3544; color: var(--text); border-color: var(--border); }
    body.dark .list { background: var(--panel); }
    body.dark .item.active { background: rgba(177,140,255,.15); }
    body.dark .hint { color: var(--muted); }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="header-row">
      <h2>Test Autocomplete</h2>
      <button id="howItWorksBtn" class="linklike" title="Xem cách hoạt động">How it works…</button>
    </div>
    <div class="layout">
      <div class="main-col">
        <div class="row inputs-grid">
          <input id="apiBase" class="form-control" type="text" placeholder="API base (vd: https://pepeapi-vv2pcyowoa-as.a.run.app)" value="https://pepeapi-vv2pcyowoa-as.a.run.app" />
          <input id="token" class="form-control" type="text" placeholder="Authorization token (vd: Pepeiscool hoặc Bearer ...)" value="Pepeiscool" />
        </div>
        <div style="height: 8px"></div>
        <div class="hint">Endpoint: <span id="endpointPreview">GET https://pepeapi-vv2pcyowoa-as.a.run.app/api/search/suggest_keywords?query=...</span></div>
        <div class="row query-grid" style="margin-top:6px;">
          <div class="q-wrap">
            <input id="q" class="form-control" type="text" placeholder="Gõ thử: r, roy, royal, thuc... (Enter để tìm)" autocomplete="off" />
            <div class="list" id="list" style="display:none"></div>
          </div>
          <select id="limit" class="form-select" title="Số kết quả / trang">
            <option value="10" selected>10</option>
            <option value="20">20</option>
            <option value="50">50</option>
          </select>
        </div>
        <div class="row" style="margin-top:8px; gap:12px; flex-wrap:wrap; align-items:center;">
          <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
            <button id="btnStats1d" class="btn btn-outline-secondary" title="GET /api/search/suggest_stats">Stats 24h</button>
            <button id="btnToggleAdmin" class="btn btn-outline-secondary" title="Hiện/ẩn khu vực Admin">Ẩn Admin</button>
            <button id="btnDarkMode" class="btn btn-outline-secondary" title="Dark / Light">Dark</button>
          </div>
          <div style="display:flex; gap:14px; flex-wrap:wrap; align-items:center;">
            <label style="margin:0; font-size:13px;"><input type="checkbox" id="showTypeScore" /> Hiện type/score</label>
            <label style="margin:0; font-size:13px;"><input type="checkbox" id="autoTrackClick" checked /> Auto click track</label>
            <span id="latencyInfo" class="hint" style="min-width:80px;"></span>
          </div>
        </div>
        <div style="height: 18px"></div>
        <div id="resultsWrap" style="display:none">
          <div id="resultsHeader" class="row" style="justify-content:space-between; align-items:center; gap:12px; flex-wrap:wrap;">
            <div style="display:flex; gap:6px; align-items:center; font-size:15px;">
              <strong>Kết quả</strong>
              <span id="queryEcho" style="color:#6b7280"></span>
            </div>
            <div style="display:flex; gap:6px; align-items:center; flex-wrap:wrap;">
              <button id="prevBtn" class="btn btn-outline-secondary" style="padding:6px 10px;">«</button>
              <div style="font-size:14px; min-width:66px; text-align:center;">Trang <span id="pageNum">1</span></div>
              <button id="nextBtn" class="btn btn-outline-secondary" style="padding:6px 10px;">»</button>
            </div>
          </div>
          <div id="didYouMeanWrap" class="hint" style="display:none; margin-top:6px;"></div>
          <div id="results" style="margin-top:8px;"></div>
        </div>
      </div>
      <div class="admin-col" id="adminSection">
        <h3 style="display:flex; align-items:center; gap:8px;">Admin: Custom Phrases</h3>
        <div class="row" style="gap:12px; flex-wrap: wrap; align-items:flex-end;">
          <div style="flex:1 1 230px;">
            <label style="display:block; font-size:12px; color:#6b7280;">Phrase (ví dụ: thức ăn cho chó)</label>
            <input id="cp_phrase" type="text" placeholder="Cụm từ chuẩn (không cần viết hoa)" />
          </div>
          <div style="flex:1 1 200px;">
            <label style="display:block; font-size:12px; color:#6b7280;">Display (tuỳ chọn)</label>
            <input id="cp_display" type="text" placeholder="Hiện thị đẹp (nếu trống dùng Phrase)" />
          </div>
          <div style="width:120px;">
            <label style="display:block; font-size:12px; color:#6b7280;">Priority</label>
            <input id="cp_priority" type="number" value="5"  class="form-control"/>
          </div>
          <div style="flex:1 1 100%; display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
            <button id="cp_add" class="btn btn-primary" style="min-width:130px;">Thêm/Update</button>
            <button id="cp_cancel" class="btn btn-outline-secondary" style="display:none;">Hủy</button>
            <button id="cp_refresh" class="btn btn-outline-secondary" title="Tải lại" style="padding:6px 12px;">↻</button>
            <button id="cp_import" class="btn btn-outline-secondary" style="white-space:nowrap;">Import (.txt)</button>
            <button id="cp_import_delete" class="btn btn-outline-danger" style="white-space:nowrap;">Import Xoá (.txt)</button>
            <input id="cp_file" type="file" accept=".txt" style="display:none;" />
            <input id="cp_delete_file" type="file" accept=".txt" style="display:none;" />
          </div>
        </div>
        <div style="margin-top:10px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
          <input id="cp_search" type="text" placeholder="Lọc nhanh (server filter)" style="flex:1; min-width:200px;" />
          <button id="cp_clear_filter" class="btn btn-outline-secondary" type="button" title="Xoá filter & tải tất cả" style="padding:6px 10px; line-height:1;">⟳</button>
          <select id="cp_limit" class="form-select" style="width:100px;">
            <option value="20">20</option>
            <option value="50" selected>50</option>
            <option value="100">100</option>
          </select>
          <div style="display:flex; gap:4px; align-items:center;">
            <button id="cp_prev" class="btn btn-outline-secondary" disabled>«</button>
            <span id="cp_page_info" class="hint">Trang 1</span>
            <button id="cp_next" class="btn btn-outline-secondary" disabled>»</button>
          </div>
        </div>
        <div id="cp_list" style="margin-top:6px; border:1px solid #e5e5e5; border-radius:6px; padding:8px;"></div>
      </div>
    </div>

    <!-- Modal: How it works -->
    <div id="howModal" class="ai-modal-backdrop" aria-hidden="true" role="dialog" aria-modal="true">
      <div class="ai-modal" role="document">
        <header>
          <h3>Cách nó hoạt động — Suggest Keywords</h3>
          <button class="close" id="howClose" aria-label="Đóng">×</button>
        </header>
        <div class="content">
          <p>Trang này kết nối tới API <code>GET /api/search/suggest_keywords</code> để gợi ý từ khóa theo thời gian thực. Hệ thống trộn kết quả từ nhiều nguồn và xếp hạng thông minh để hiển thị danh sách bạn thấy bên dưới ô tìm kiếm.</p>
          <h4>Nguồn gợi ý chính</h4>
          <ul>
            <li><strong>Prefix</strong>: Hoàn tất token đang gõ theo tiền tố.</li>
            <li><strong>Neighbor (PPMI)</strong>: Từ/cụm từ có quan hệ thống kê cao với token trước đó.</li>
            <li><strong>Next token</strong>: Dự đoán từ tiếp theo theo ngữ cảnh 1–2 bước.</li>
            <li><strong>Phrase</strong>: Mở rộng thành cụm nhiều token dựa trên chuỗi next-token.</li>
            <li><strong>Phrase dictionary</strong>: Cụm mined sẵn (n-gram) vượt ngưỡng PMI.</li>
            <li><strong>Custom</strong>: Cụm do Admin quản trị (ưu tiên cao).</li>
            <li><strong>Embedding</strong> (tuỳ chọn): Hàng xóm nghĩa dựa trên embedding.</li>
          </ul>
          <h4>Hiệu năng & Cache</h4>
          <p>Truy vấn được chuẩn hoá, chạy song song các nhánh chính và cache trong Redis ~20s theo <code>query</code> + cờ có/không khoảng trắng ở cuối. Header <code>x-suggest-latency-ms</code> hiển thị độ trễ xử lý.</p>
          <h4>Học online</h4>
          <p>Nếu bật, hệ thống thu thập <em>click</em> trên gợi ý và truy vấn tìm kiếm để cải thiện gợi ý theo thời gian.</p>
          <h4>Admin: Custom Phrases</h4>
          <p>Bạn có thể thêm/sửa/xoá cụm ưu tiên ở khu vực Admin (nút “Hiện Admin”). Cụm này có thể được <em>pin</em> ở đầu danh sách.</p>
          <h4>Auth</h4>
          <p>Các API yêu cầu header <code>Authorization: Bearer &lt;token&gt;</code>. Ô token bên trên chấp nhận cả dạng thuần lẫn tiền tố <code>Bearer</code> và sẽ tự chuẩn hoá khi gửi.</p>
          <h4>Tham khảo</h4>
          <p>Nội dung chi tiết hơn nằm trong README đính kèm. Phần tóm tắt ở đây được cô đọng cho mục đích dùng nhanh.</p>
          <hr class="my-3"/>
          <div class="d-flex flex-wrap gap-2">
            <a href="README_suggest_keywords_full.md" class="btn btn-sm btn-outline-primary" download>Tải Full README v2 (.md)</a>
            <a href="readme.html?file=full" class="btn btn-sm btn-link" target="_blank" rel="noopener">Xem Full README</a>
            <a href="readme.html?file=overview" class="btn btn-sm btn-link" target="_blank" rel="noopener">Xem Overview</a>
          </div>
        </div>
      </div>
    </div>
    <!-- Modal: Import guide -->
    <div id="importModal" class="ai-modal-backdrop" aria-hidden="true" role="dialog" aria-modal="true">
      <div class="ai-modal" role="document">
        <header>
          <h3>Hướng dẫn Import Custom Phrases</h3>
          <button class="close" id="importClose" aria-label="Đóng">×</button>
        </header>
        <div class="content">
          <p>File phải là <strong>.txt</strong>. Mỗi dòng trong file tương ứng <strong>1 custom phrase</strong>.</p>
          <ul>
            <li>Các dòng trống sẽ bị bỏ qua tự động.</li>
            <li>Không cần viết hoa đầu câu hay dấu ở cuối.</li>
            <li>Hãy chọn trước <strong>Priority</strong> (ô Priority ở form). Tất cả phrase trong file sẽ dùng chung priority đó.</li>
            <li>Nếu phrase đã tồn tại: backend sẽ <strong>merge</strong> (giữ display cũ trừ khi bạn nhập display mới ở form; priority sẽ lấy giá trị cao hơn giữa cũ và mới).</li>
          </ul>
          <p>Sau khi bấm <em>“Đã hiểu, chọn file…”</em> hệ thống sẽ mở hộp thoại để bạn chọn file .txt. Nhấn <em>Back</em> hoặc click ra ngoài để huỷ.</p>
          <div class="d-flex flex-wrap gap-2 mt-3">
            <button id="importBack" class="btn btn-outline-secondary" type="button">Back</button>
            <button id="importOk" class="btn btn-primary" type="button">Đã hiểu, chọn file…</button>
          </div>
        </div>
      </div>
    </div>
  <!-- Modal: Import Delete guide (flexible match) -->
    <div id="importDelModal" class="ai-modal-backdrop" aria-hidden="true" role="dialog" aria-modal="true">
      <div class="ai-modal" role="document">
        <header>
          <h3>Import danh sách cần XÓA</h3>
          <button class="close" id="importDelClose" aria-label="Đóng">×</button>
        </header>
        <div class="content">
          <p>File phải là <strong>.txt</strong>. Mỗi dòng = 1 cụm cần xoá.</p>
          <ul>
            <li>Dòng trống sẽ bỏ qua.</li>
            <li>Hệ thống sẽ tìm theo <code>phrase</code> (exact, case-insensitive & bỏ dấu) trước; nếu không thấy thử match <code>display</code>.</li>
            <li>Nếu nhiều kết quả: chọn kết quả ưu tiên match phrase exact, sau đó tới display, cuối cùng lấy dòng đầu.</li>
            <li>Nếu không tìm được gì: ghi dòng đó vào danh sách <em>Not Found</em>.</li>
          </ul>
          <p>Sau khi bấm <em>“Đã hiểu, chọn file…”</em> chọn file .txt. Hệ thống xoá theo batch & báo thống kê.</p>
          <div class="d-flex flex-wrap gap-2 mt-3">
            <button id="importDelBack" class="btn btn-outline-secondary" type="button">Back</button>
            <button id="importDelOk" class="btn btn-danger" type="button">Đã hiểu, chọn file…</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const $ = (sel) => document.querySelector(sel);
    const apiBase = $('#apiBase');
    const token = $('#token');
    const q = $('#q');
  const list = $('#list');
  const limitSel = $('#limit');
  const resultsWrap = $('#resultsWrap');
  const results = $('#results');
  const pageNum = $('#pageNum');
  const prevBtn = $('#prevBtn');
  const nextBtn = $('#nextBtn');
  const queryEcho = $('#queryEcho');
  const didYouMeanWrap = $('#didYouMeanWrap');
  const endpointPreview = document.getElementById('endpointPreview');
  const showTypeScore = document.getElementById('showTypeScore');
  const autoTrackClick = document.getElementById('autoTrackClick');
  const btnRebuildVectors = document.getElementById('btnRebuildVectors');
  const btnRebuildDict = document.getElementById('btnRebuildDict');
  const btnStats1d = document.getElementById('btnStats1d');
  const latencyInfo = document.getElementById('latencyInfo');
  const cp_phrase = document.getElementById('cp_phrase');
  const cp_display = document.getElementById('cp_display');
  const cp_priority = document.getElementById('cp_priority');
  const cp_add = document.getElementById('cp_add');
  const cp_cancel = document.getElementById('cp_cancel');
  const cp_refresh = document.getElementById('cp_refresh');
  const cp_list = document.getElementById('cp_list');
  const cp_search = document.getElementById('cp_search');
  const cp_clear_filter = document.getElementById('cp_clear_filter');
  const cp_limit = document.getElementById('cp_limit');
  const cp_prev = document.getElementById('cp_prev');
  const cp_next = document.getElementById('cp_next');
  const cp_page_info = document.getElementById('cp_page_info');
  const cp_import = document.getElementById('cp_import');
  const cp_file = document.getElementById('cp_file');
  const cp_import_delete = document.getElementById('cp_import_delete');
  const cp_delete_file = document.getElementById('cp_delete_file');
  const adminSection = document.getElementById('adminSection');
  const btnToggleAdmin = document.getElementById('btnToggleAdmin');
  const howItWorksBtn = document.getElementById('howItWorksBtn');
  const howModal = document.getElementById('howModal');
  const howClose = document.getElementById('howClose');
  const btnDarkMode = document.getElementById('btnDarkMode');
  // Import modal elements
  const importModal = document.getElementById('importModal');
  const importClose = document.getElementById('importClose');
  const importOk = document.getElementById('importOk');
  const importBack = document.getElementById('importBack');
  const importDelModal = document.getElementById('importDelModal');
  const importDelClose = document.getElementById('importDelClose');
  const importDelOk = document.getElementById('importDelOk');
  const importDelBack = document.getElementById('importDelBack');

    let timer;
    let activeIndex = -1;
  let currentPage = 1;

      // Modal helpers
      function openHowModal() {
        if (!howModal) return;
        howModal.style.display = 'flex';
        howModal.setAttribute('aria-hidden', 'false');
      }
      function closeHowModal() {
        if (!howModal) return;
        howModal.style.display = 'none';
        howModal.setAttribute('aria-hidden', 'true');
      }
      howItWorksBtn?.addEventListener('click', openHowModal);
      howClose?.addEventListener('click', closeHowModal);
      howModal?.addEventListener('click', (e) => { if (e.target === howModal) closeHowModal(); });
      document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeHowModal(); });

      // Import modal helpers
      function openImportModal() {
        if (!importModal) return;
        importModal.style.display = 'flex';
        importModal.setAttribute('aria-hidden', 'false');
      }
      function closeImportModal() {
        if (!importModal) return;
        importModal.style.display = 'none';
        importModal.setAttribute('aria-hidden', 'true');
      }
      importClose?.addEventListener('click', closeImportModal);
      importBack?.addEventListener('click', closeImportModal);
      importModal?.addEventListener('click', (e) => { if (e.target === importModal) closeImportModal(); });
      document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeImportModal(); });
      importOk?.addEventListener('click', () => {
        closeImportModal();
        if (cp_file) {
          cp_file.value = '';
          // slight delay to ensure modal close animation (if any) completes
          setTimeout(() => cp_file.click(), 30);
        }
      });

      // Import DELETE modal helpers
      function openImportDelModal() {
        if (!importDelModal) return;
        importDelModal.style.display = 'flex';
        importDelModal.setAttribute('aria-hidden', 'false');
      }
      function closeImportDelModal() {
        if (!importDelModal) return;
        importDelModal.style.display = 'none';
        importDelModal.setAttribute('aria-hidden', 'true');
      }
      importDelClose?.addEventListener('click', closeImportDelModal);
      importDelBack?.addEventListener('click', closeImportDelModal);
      importDelModal?.addEventListener('click', (e) => { if (e.target === importDelModal) closeImportDelModal(); });
      document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeImportDelModal(); });
      importDelOk?.addEventListener('click', () => {
        closeImportDelModal();
        if (cp_delete_file) {
          cp_delete_file.value = '';
          setTimeout(() => cp_delete_file.click(), 30);
        }
      });

      // Modal handlers
      let cpPage = 1;
      let cpTotalPages = 1;
      function updateCpPageInfo(total, limit) {
        cp_page_info.textContent = `Trang ${cpPage}/${cpTotalPages}`;
        cp_prev.disabled = cpPage <= 1;
        cp_next.disabled = cpPage >= cpTotalPages;
      }

      // Track editing id (moved up to avoid TDZ when loadCustomPhrases() runs early)
      let editingId = null;

      async function loadCustomPhrases(opts = {}) {
        if (opts.resetPage) cpPage = 1;
        const base = apiBase.value.replace(/\/$/, '');
        const limit = parseInt(cp_limit.value, 10) || 50;
        const qFilter = (cp_search.value || '').trim();
        const params = new URLSearchParams({ limit: String(limit), page: String(cpPage) });
        if (qFilter) params.set('q', qFilter);
        const url = `${base}/api/search/custom_phrases?${params.toString()}`;
        const headers = {};
        const tk = token.value.trim();
        if (tk) headers['Authorization'] = tk.startsWith('Bearer ') ? tk : `Bearer ${tk}`;
        const res = await fetch(url, { headers });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const json = await res.json();
        const rows = json?.data || [];
        const meta = json?.pagination || {};
        cpTotalPages = meta.pages || 1;
        cp_list.innerHTML = '';
        rows.forEach((r) => {
          const rid = r?._id || r?.id || r?._doc?._id || r?.pk || '';
          const div = document.createElement('div');
          div.style.display = 'flex';
          div.style.justifyContent = 'space-between';
          div.style.alignItems = 'center';
          div.style.padding = '6px 8px';
          div.style.borderBottom = '1px solid #eee';
          const title = document.createElement('div');
          const idText = escapeHtml(String(rid || ''));
          title.innerHTML = `<strong>${escapeHtml(r.display || r.phrase)}</strong><br/><span class="hint">${escapeHtml((r.tokens || []).join(' '))} • priority ${r.priority} • id ${idText}</span>`;
          const actions = document.createElement('div');
          actions.style.display = 'flex';
          actions.style.gap = '8px';
          const editBtn = document.createElement('button');
          editBtn.textContent = 'Sửa';
          editBtn.addEventListener('click', () => {
            editingId = rid;
            cp_phrase.value = r.phrase || '';
            cp_display.value = r.display || '';
            cp_priority.value = (r.priority ?? 1);
            cp_add.textContent = 'Lưu (Update)';
            cp_cancel.style.display = 'inline-block';
            if (!showAdmin) btnToggleAdmin.click();
          });
          const delBtn = document.createElement('button');
          delBtn.textContent = 'Xoá';
          delBtn.addEventListener('click', async () => {
            if (!rid) return alert('Không tìm thấy id để xoá');
            if (!confirm('Xoá mục này?')) return;
            try {
              const ok = await deleteCustomPhrase(rid);
              if (!ok) return;
              await loadCustomPhrases();
            } catch(e) { alert(String(e)); }
          });
          actions.appendChild(editBtn);
          actions.appendChild(delBtn);
          div.appendChild(title);
            div.appendChild(actions);
          cp_list.appendChild(div);
        });
        if (!rows.length) cp_list.innerHTML = '<div class="hint">Chưa có phrase nào.</div>';
        updateCpPageInfo();
      }

    function setList(items) {
      list.innerHTML = '';
      if (!items || items.length === 0) {
        list.style.display = 'none';
        return;
      }
      items.forEach((it, idx) => {
        const div = document.createElement('div');
        div.className = 'item' + (idx === activeIndex ? ' active' : '');
        // Hiện type/score khi bật checkbox
        const badge = showTypeScore.checked ? `<span class="badge">${escapeHtml(it.type || '')}${typeof it.score !== 'undefined' ? `:${String(it.score)}` : ''}</span>` : '';
        div.innerHTML = `${badge}<span>${renderHighlight(it)}</span>`;
        div.addEventListener('mousedown', (e) => {
          e.preventDefault();
          const beforeQ = q.value;
          q.value = it.full || it.text;
          if (autoTrackClick.checked) {
            trackSuggestClick(beforeQ, it).catch(err => console.warn('track click error', err));
          }
          list.style.display = 'none';
          console.log('Selected:', it);
        });
        list.appendChild(div);
      });
      list.style.display = 'block';
      // keep active item visible when navigating with arrows
      if (activeIndex >= 0 && list.children[activeIndex]) {
        list.children[activeIndex].scrollIntoView({ block: 'nearest' });
      }
    }

    function escapeHtml(str) {
      return String(str || '').replace(/[&<>"]+/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[s]));
    }

    let lastSuggestLatency = null;
    async function fetchSuggest(v) {
      const base = apiBase.value.replace(/\/$/, '');
      const url = `${base}/api/search/suggest_keywords?query=${encodeURIComponent(v)}`;
      const headers = {};
      const tk = token.value.trim();
      if (tk) headers['Authorization'] = tk.startsWith('Bearer ') ? tk : `Bearer ${tk}`;
      const res = await fetch(url, { headers });
      if (!res.ok) throw new Error('HTTP ' + res.status);
      lastSuggestLatency = res.headers.get('x-suggest-latency-ms');
      latencyInfo.textContent = lastSuggestLatency ? `Latency: ${lastSuggestLatency} ms` : '';
      const json = await res.json();
      return json?.data || [];
    }

    // Fetch custom phrases suggestions (filter) to merge into dropdown
    async function fetchCustomPhraseSuggest(v) {
      const base = apiBase.value.replace(/\/$/, '');
      const qParam = v.trim();
      if (!qParam) return [];
      const url = `${base}/api/search/custom_phrases?q=${encodeURIComponent(qParam)}&limit=20&page=1`;
      const headers = {};
      const tk = token.value.trim();
      if (tk) headers['Authorization'] = tk.startsWith('Bearer ') ? tk : `Bearer ${tk}`;
      try {
        const res = await fetch(url, { headers });
        if (!res.ok) return [];
        const json = await res.json();
        const rows = json?.data || [];
        return rows.map(r => ({
          text: r.display || r.phrase,
          full: r.display || r.phrase,
          type: 'custom',
          score: r.priority ?? 0,
          priority: r.priority ?? 0,
          _src: 'custom',
        }));
      } catch { return []; }
    }

    function onInput() {
      clearTimeout(timer);
      const v = q.value; // không trim để giữ khoảng trắng cuối
      if (!v || !v.replace(/\s+/g, '')) { setList([]); return; }
      timer = setTimeout(async () => {
        try {
          // Parallel fetch keyword + custom
          const [kwItems, customItems] = await Promise.all([
            fetchSuggest(v),
            fetchCustomPhraseSuggest(v)
          ]);
          // Dedupe by lowercased text
          const seen = new Set();
          const merged = [];
          const push = (arr) => arr.forEach(it => {
            const key = String(it.full || it.text || '').toLowerCase();
            if (!key) return;
            if (seen.has(key)) return;
            seen.add(key);
            merged.push(it);
          });
          // Custom phrases come first
          push(customItems);
          push(kwItems);
          activeIndex = merged.length ? 0 : -1;
          setList(merged);
        } catch (e) {
          console.error('Suggest error', e);
          setList([]);
        }
      }, 120);
      updateEndpoint();

      // Debounced sync of custom phrases list with main query when Admin visible
      if (showAdmin) {
        if (cp_search) cp_search.value = v.trim();
        clearTimeout(window.__cpSyncTimer);
        window.__cpSyncTimer = setTimeout(() => {
          if (!editingId) {
            loadCustomPhrases({ resetPage: true }).catch(()=>{});
          }
        }, 400);
      }
    }

    q.addEventListener('input', onInput);
    q.addEventListener('focus', onInput);
    q.addEventListener('blur', () => setTimeout(() => list.style.display = 'none', 150));
  apiBase.addEventListener('input', () => updateEndpoint());

    q.addEventListener('keydown', (e) => {
      const items = Array.from(list.children);
      // If no suggestion items, allow default behavior (including Tab navigation)
      if (!items.length) return;
      if (e.key === 'ArrowDown') {
        e.preventDefault();
        activeIndex = (activeIndex + 1) % items.length;
        // chỉ cập nhật active class, không render lại từ DOM để giữ highlight
        setList(currentItemsCache);
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        activeIndex = (activeIndex - 1 + items.length) % items.length;
        setList(currentItemsCache);
      } else if (e.key === 'Tab') {
        // Apply the first suggestion on Tab
        if (currentItemsCache && currentItemsCache.length > 0) {
          e.preventDefault();
          const chosen = currentItemsCache[0];
          const beforeQ = q.value;
          q.value = chosen.full || chosen.text || q.value;
          if (autoTrackClick.checked) {
            trackSuggestClick(beforeQ, chosen).catch(err => console.warn('track click error', err));
          }
          list.style.display = 'none';
          updateEndpoint();
        }
      }
    });

    // Global keydown for Enter to trigger search
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        // Nếu đang có danh sách gợi ý và có item active, nhận item đó vào input trước
        const items = Array.from(list.children);
        if (items.length && activeIndex >= 0 && activeIndex < items.length && currentItemsCache[activeIndex]) {
          const chosen = currentItemsCache[activeIndex];
          q.value = chosen.full || chosen.text;
        }
        list.style.display = 'none';
        // Thực thi search trang 1
        doSearch(1);
      }
    });

    // Cache last items to keep highlight rendering stable across key navigation
    let currentItemsCache = [];
    const normalize = (s) => (s || '').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '').replace(/[.,/#!$%^&*;:{}=\-_`~()\[\]'"+|<>?]/g, ' ').replace(/\s+/g, ' ').trim();
    function renderHighlight(it) {
      // Bôi đậm từng token người dùng đã gõ xuất hiện trong cụm gợi ý (không phân biệt hoa/thường & dấu)
      const queryRaw = q.value || '';
      const phrase = String(it.full || it.text || '');
      if (!queryRaw.trim()) return escapeHtml(phrase);

      // Chuẩn hoá để so khớp (bỏ dấu tiếng Việt, ký tự đặc biệt -> space)
      const normalize = (s) => (s||'').toLowerCase().normalize('NFD')
        .replace(/[\u0300-\u036f]/g,'')
        .replace(/[^a-z0-9àáạảãăằắặẳẵâầấậẩẫèéẹẻẽêềếệểễìíịỉĩòóọỏõôồốộổỗơờớợởỡùúụủũưừứựửữỳýỵỷỹđ\s]/g,' ')
        .replace(/\s+/g,' ') // collapse
        .trim();

      // Tokenize query (giữ thứ tự, loại token ngắn rỗng)
      const qTokens = normalize(queryRaw).split(' ').filter(t => t.length);
      if (!qTokens.length) return escapeHtml(phrase);

      // Duyệt phrase theo ký tự, tạo map vị trí các lần khớp token (ưu tiên dài hơn)
      const normPhrase = normalize(phrase);
      // Ta cần ánh xạ index trong normPhrase về index trong original phrase.
      // Cách đơn giản: tạo mảng mapChar từ normPhrase char -> original substring index.
      const originalChars = [...phrase];
      const lowered = phrase.toLowerCase();
      // Để đơn giản & vẫn chính xác phần lớn: Khi highlight ta dựa vào substring trong phiên bản thường (lowered) tìm trong lowered.

      // Sắp xếp token theo độ dài giảm để tránh lồng highlight ("thuc an" chứa "thuc")
      const sortedTokens = [...new Set(qTokens)].sort((a,b)=>b.length - a.length);

      // Ta sẽ xây dựng một mảng các đoạn {text, hit:boolean}
      const segments = [];
      let i = 0;
      const loweredNoAccent = normalize(lowered); // lowered đã bỏ dấu qua normalize()
      // Ta cũng cần mapping giữa loweredNoAccent và lowered (có dấu) để cắt theo index.
      // Tạo chuỗi loweredNoAccentFromOriginal đi từng char original => char đã normalize (chỉ lấy nhóm base)
      const map = []; // map index trong loweredNoAccent -> index bắt đầu trong phrase original
      const rebuilt = []; // rebuilt chuỗi từ original theo normalize char-by-char
      for (let oi=0; oi<phrase.length; oi++) {
        const ch = phrase[oi];
        const base = ch.normalize('NFD').replace(/[\u0300-\u036f]/g,'');
        // base có thể >1 (hiếm), ta lấy từng char
        for (const bc of base) {
          map.push(oi);
          rebuilt.push(bc.toLowerCase());
        }
      }
      const rebuiltStr = rebuilt.join('');

      // Đánh dấu các khoảng match trong rebuiltStr
      // Tạo array same length with false
      const mark = new Array(rebuiltStr.length).fill(false);
      for (const tok of sortedTokens) {
        if (!tok) continue;
        let start = 0;
        while (start < rebuiltStr.length) {
          const idx = rebuiltStr.indexOf(tok, start);
          if (idx === -1) break;
            // Kiểm tra ranh giới từ (trước & sau không phải chữ/ số) để tránh highlight bên trong từ dài khác
            const leftOk = idx === 0 || /[^a-z0-9]/.test(rebuiltStr[idx-1]);
            const rightPos = idx + tok.length;
            const rightOk = rightPos === rebuiltStr.length || /[^a-z0-9]/.test(rebuiltStr[rightPos]);
            if (leftOk && rightOk) {
              for (let k = idx; k < idx + tok.length; k++) mark[k] = true;
            }
            start = idx + tok.length; // tiếp tục sau match
        }
      }

      // Convert mark array thành segments dựa trên original phrase indexes
      let curHit = mark[0] || false;
      let segStart = 0;
      for (let pos=1; pos<=mark.length; pos++) {
        if (pos === mark.length || mark[pos] !== curHit) {
          // segment từ segStart..pos-1 trong rebuiltStr -> mapping sang original indexes
          const origStart = map[segStart];
          const origEnd = map[pos-1] + 1; // slice end
          const textSeg = phrase.slice(origStart, origEnd);
          segments.push({ text: textSeg, hit: curHit });
          segStart = pos;
          curHit = mark[pos];
        }
      }
      // Gộp lại thành HTML
      return segments.map(s => `<span class="${s.hit? 'suggest-hit':'suggest-frag'}">${escapeHtml(s.text)}</span>`).join('');
    }

    // Override setList to keep cache in sync
    const _setList = setList;
    setList = function(items) {
      currentItemsCache = items;
      _setList(items);
    }

    function updateEndpoint() {
      const base = (apiBase.value || '').replace(/\/$/, '') || 'https://pepeapi-vv2pcyowoa-as.a.run.app';
      const v = q.value || '';
      const qs = `?query=${encodeURIComponent(v)}`;
      endpointPreview.textContent = `GET ${base}/api/search/suggest_keywords${qs}`;
    }

    // Initialize endpoint preview once
    updateEndpoint();

    // Admin toggle: persist to localStorage
    const ADMIN_TOGGLE_KEY = 'showAdmin@autocomplete';
  const DARK_MODE_KEY = 'darkMode@autocomplete';
    function applyAdminVisibility(show) {
      adminSection.style.display = show ? 'block' : 'none';
      btnToggleAdmin.textContent = show ? 'Ẩn Admin' : 'Hiện Admin';
    }
    const savedShowAdmin = localStorage.getItem(ADMIN_TOGGLE_KEY);
    let showAdmin = savedShowAdmin === null ? false : savedShowAdmin === '1';
    applyAdminVisibility(showAdmin);
    // Auto collapse on mobile first load
    function isMobileWidth(){ return window.innerWidth < 780; }
    if (isMobileWidth()) {
      // Override to collapsed unless user explicitly enabled before
      if (savedShowAdmin === null) {
        showAdmin = false;
        applyAdminVisibility(false);
      }
    }
    if (showAdmin) {
      // preload list when visible
      loadCustomPhrases().catch(()=>{});
    }
    btnToggleAdmin?.addEventListener('click', () => {
      showAdmin = !showAdmin;
      applyAdminVisibility(showAdmin);
      localStorage.setItem(ADMIN_TOGGLE_KEY, showAdmin ? '1' : '0');
      if (showAdmin) {
        loadCustomPhrases().catch(()=>{});
      }
    });

    // Dark mode persistence
    const savedDark = localStorage.getItem(DARK_MODE_KEY);
    if (savedDark === '1') {
      document.body.classList.add('dark');
      if (btnDarkMode) btnDarkMode.textContent = 'Light';
    }
    btnDarkMode?.addEventListener('click', () => {
      const dark = document.body.classList.toggle('dark');
      localStorage.setItem(DARK_MODE_KEY, dark ? '1':'0');
      btnDarkMode.textContent = dark ? 'Light' : 'Dark';
    });

    window.addEventListener('resize', () => {
      if (isMobileWidth() && showAdmin && adminSection.style.display !== 'none') {
        // keep as user set; no force collapse after interaction
        return;
      }
    });

    // Helpers
    async function trackSuggestClick(qBefore, item) {
      const base = apiBase.value.replace(/\/$/, '');
      const url = `${base}/api/search/suggest_click`;
      const headers = { 'Content-Type': 'application/json' };
      const tk = token.value.trim();
      if (tk) headers['Authorization'] = tk.startsWith('Bearer ') ? tk : `Bearer ${tk}`;
      const body = {
        q: String(qBefore || ''),
        chosen: String(item?.full || item?.text || ''),
        token: String(item?.token || ''),
        type: String(item?.type || ''),
      };
      const res = await fetch(url, { method: 'POST', headers, body: JSON.stringify(body) });
      if (!res.ok) throw new Error('track click HTTP ' + res.status);
      return await res.json();
    }

    async function postNoBody(path) {
      const base = apiBase.value.replace(/\/$/, '');
      const url = `${base}${path}`;
      const headers = {};
      const tk = token.value.trim();
    if (tk) headers['Authorization'] = tk.startsWith('Bearer ') ? tk : `Bearer ${tk}`;
      const t0 = performance.now();
      const res = await fetch(url, { method: 'POST', headers });
      const dt = Math.round(performance.now() - t0);
      if (!res.ok) throw new Error(path + ' HTTP ' + res.status);
      const json = await res.json();
      alert(`${path} OK (${dt}ms)\n` + JSON.stringify(json?.data || json, null, 2));
    }

    btnRebuildVectors?.addEventListener('click', () => postNoBody('/api/search/rebuild_keyword_vectors').catch(e => alert(e)));
    btnRebuildDict?.addEventListener('click', () => postNoBody('/api/search/rebuild_dictionary').catch(e => alert(e)));

    btnStats1d?.addEventListener('click', async () => {
      try {
        const base = apiBase.value.replace(/\/$/, '');
        const url = new URL(`${base}/api/search/suggest_stats`);
        const now = new Date();
        const from = new Date(now.getTime() - 24 * 60 * 60 * 1000).toISOString();
        const to = now.toISOString();
        url.searchParams.set('from', from);
        url.searchParams.set('to', to);
        const headers = {};
        const tk = token.value.trim();
        if (tk) headers['Authorization'] = tk.startsWith('Bearer ') ? tk : `Bearer ${tk}`;
        const res = await fetch(url.toString(), { headers });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const json = await res.json();
        alert('Suggest stats 24h:\n' + JSON.stringify(json?.data || json, null, 2));
      } catch (e) {
        alert(String(e));
      }
    });

    // Admin: custom phrases (listeners using paginated loadCustomPhrases)

    cp_refresh?.addEventListener('click', () => loadCustomPhrases({}).catch(e => alert(String(e))));
    cp_limit?.addEventListener('change', () => loadCustomPhrases({ resetPage: true }).catch(e => console.warn(e)) );
    cp_prev?.addEventListener('click', () => { if (cpPage > 1) { cpPage--; loadCustomPhrases().catch(()=>{}); }});
    cp_next?.addEventListener('click', () => { if (cpPage < cpTotalPages) { cpPage++; loadCustomPhrases().catch(()=>{}); }});
    let cpSearchTimer;
    cp_search?.addEventListener('input', () => {
      clearTimeout(cpSearchTimer);
      cpSearchTimer = setTimeout(() => loadCustomPhrases({ resetPage: true }).catch(()=>{}), 350);
    });
    cp_clear_filter?.addEventListener('click', () => {
      if (cp_search) cp_search.value = '';
      loadCustomPhrases({ resetPage: true }).catch(()=>{});
    });
    cp_cancel?.addEventListener('click', () => {
      editingId = null;
      cp_add.textContent = 'Thêm/Update';
      cp_cancel.style.display = 'none';
      cp_phrase.value = '';
      cp_display.value = '';
    });

    cp_add?.addEventListener('click', async () => {
      try {
        const base = apiBase.value.replace(/\/$/, '');
        let url = `${base}/api/search/custom_phrases`;
        const headers = { 'Content-Type': 'application/json' };
        const tk = token.value.trim();
      if (tk) headers['Authorization'] = tk.startsWith('Bearer ') ? tk : `Bearer ${tk}`;
        const payload = {
          phrase: String(cp_phrase.value || ''),
          display: String(cp_display.value || ''),
          priority: parseFloat(cp_priority.value) || 1,
        };
        if (!payload.phrase.trim()) return alert('Nhập Phrase');
        if (editingId) {
          // Update only with PUT (avoid POST fallback to prevent accidental new doc)
          // 1) PUT /custom_phrases with body.id
          let res = await fetch(url, { method: 'PUT', headers, body: JSON.stringify({ id: editingId, ...payload }) });
          // 2) Fallback: PUT /custom_phrases/:id
          if (!res.ok) {
            res = await fetch(`${url}/${encodeURIComponent(editingId)}`, { method: 'PUT', headers, body: JSON.stringify(payload) });
          }
          // 3) Fallback: PUT /custom_phrases?id=...
          if (!res.ok) {
            res = await fetch(`${url}?id=${encodeURIComponent(editingId)}`, { method: 'PUT', headers, body: JSON.stringify(payload) });
          }
          if (!res.ok) {
            const text = await res.text().catch(()=>'');
            throw new Error('Update thất bại: ' + res.status + (text? `\n${text}`:''));
          }
          alert('Đã cập nhật');
        } else {
          const res = await fetch(url, { method: 'POST', headers, body: JSON.stringify(payload) });
          if (!res.ok) throw new Error('HTTP ' + res.status);
          alert('Đã thêm');
        }
        // reset form
        editingId = null;
        cp_add.textContent = 'Thêm/Update';
        cp_cancel.style.display = 'none';
        cp_phrase.value = '';
        cp_display.value = '';
        loadCustomPhrases({ resetPage: true }).catch(e => alert(String(e)));
      } catch (e) {
        alert(String(e));
      }
    });

    // Import file (.txt) — show instruction modal first
    cp_import?.addEventListener('click', () => {
      if (importModal) openImportModal(); else cp_file?.click();
    });
    cp_import_delete?.addEventListener('click', () => {
      if (importDelModal) openImportDelModal(); else cp_delete_file?.click();
    });
    cp_file?.addEventListener('change', async (ev) => {
      const file = ev.target.files?.[0];
      if (!file) return;
      try {
        const text = await file.text();
        const lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
        if (!lines.length) return alert('File rỗng hoặc không có dòng hợp lệ');
        const unique = Array.from(new Set(lines));
        if (!confirm(`Import ${unique.length} dòng?`)) return;
        const base = apiBase.value.replace(/\/$/, '');
  const url = `${base}/api/search/custom_phrases?merge=1`;
        const headers = { 'Content-Type': 'application/json' };
        const tk = token.value.trim();
        if (tk) headers['Authorization'] = tk.startsWith('Bearer ') ? tk : `Bearer ${tk}`;
        const prio = parseFloat(cp_priority.value) || 1;
        let okCount = 0, failCount = 0;
        const t0 = performance.now();
        // send in small batches to avoid overload
        const chunkSize = 10;
        for (let i = 0; i < unique.length; i += chunkSize) {
          const chunk = unique.slice(i, i + chunkSize);
          await Promise.all(chunk.map(async phrase => {
            const payload = { phrase, display: '', priority: prio };
            const res = await fetch(url, { method: 'POST', headers, body: JSON.stringify(payload) });
            if (res.ok) okCount++; else failCount++;
          }));
        }
        const dt = Math.round(performance.now() - t0);
        alert(`Import xong: ${okCount} OK, ${failCount} lỗi (${dt}ms)`);
        await loadCustomPhrases();
      } catch (e) {
        alert('Import lỗi: ' + String(e));
      } finally {
        ev.target.value = '';
      }
    });

    // Bulk delete import (.txt) — flexible resolve (phrase/display)
    cp_delete_file?.addEventListener('change', async (ev) => {
      const file = ev.target.files?.[0];
      if (!file) return;
      try {
        const text = await file.text();
        const lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
        if (!lines.length) return alert('File rỗng hoặc không có dòng hợp lệ');
        if (!confirm(`Xoá theo file: ${lines.length} dòng?`)) return;
        const base = apiBase.value.replace(/\/$/, '');
  const headers = { 'Content-Type': 'application/json' };
        const tk = token.value.trim();
        if (tk) headers['Authorization'] = tk.startsWith('Bearer ') ? tk : `Bearer ${tk}`;
  let deleted = 0, notFound = [], failed = [];
        const t0 = performance.now();
        async function resolveId(line){
          try {
            const qUrl = `${base}/api/search/custom_phrases?q=${encodeURIComponent(line)}&limit=20&page=1`;
            const res = await fetch(qUrl, { headers });
            if (!res.ok) return { id: null, phrase: line };
            const js = await res.json();
            const rows = js?.data || [];
            if (!rows.length) return { id: null, phrase: line };
            const fold = (s)=> (s||'').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,'');
            const lineFold = fold(line);
            let cand = rows.find(r => fold(r.phrase||'') === lineFold);
            if (!cand) cand = rows.find(r => fold(r.display||'') === lineFold);
            if (!cand) cand = rows[0];
            const id = cand._id || cand.id || cand.pk || cand.phrase;
            return { id, phrase: cand.phrase || line };
          } catch { return { id: null, phrase: line }; }
        }
        const chunkSize = 10;
        for (let i = 0; i < lines.length; i += chunkSize) {
          const chunk = lines.slice(i, i + chunkSize);
            await Promise.all(chunk.map(async line => {
              const { id } = await resolveId(line);
              const delBody = { id: id || line };
              try {
                const res = await fetch(`${base}/api/search/custom_phrases`, { method: 'DELETE', headers, body: JSON.stringify(delBody) });
                if (res.ok) {
                  deleted++; return;
                }
                // fallback query param
                const res2 = await fetch(`${base}/api/search/custom_phrases?id=${encodeURIComponent(id || line)}`, { method: 'DELETE', headers });
                if (res2.ok) { deleted++; return; }
                // fallback path param
                const res3 = await fetch(`${base}/api/search/custom_phrases/${encodeURIComponent(id || line)}`, { method: 'DELETE', headers });
                if (res3.ok) { deleted++; return; }
                if (res.status === 404 || res2.status === 404 || res3.status === 404) notFound.push(line); else failed.push(line);
              } catch { failed.push(line); }
            }));
        }
        const dt = Math.round(performance.now() - t0);
        let msg = `Xoá xong: ${deleted} OK / ${lines.length}\n`;
        if (notFound.length) msg += `Not found (${notFound.length}): ${notFound.slice(0,5).join(', ')}${notFound.length>5?' ...':''}\n`;
        if (failed.length) msg += `Failed (${failed.length}): ${failed.slice(0,5).join(', ')}${failed.length>5?' ...':''}\n`;
        msg += `Latency: ${dt}ms`;
        alert(msg);
        await loadCustomPhrases();
      } catch (e) {
        alert('Import xoá lỗi: ' + String(e));
      } finally {
        ev.target.value = '';
      }
    });

    // Search and pagination
    async function fetchSearch(query, page, limit) {
      const base = apiBase.value.replace(/\/$/, '');
      const params = new URLSearchParams({
        query: query,
        sort: 'related_score desc',
        limit: String(limit),
        page: String(page),
      });
      const url = `${base}/api/search?${params.toString()}`;
      const headers = {};
      const tk = token.value.trim();
    if (tk) headers['Authorization'] = tk.startsWith('Bearer ') ? tk : `Bearer ${tk}`;
      const res = await fetch(url, { headers });
      if (!res.ok) throw new Error('HTTP ' + res.status);
      const json = await res.json();
      return json?.data || [];
    }

    async function doSearch(page = 1) {
      const query = (q.value || '').trim();
      if (!query) return;
      const limit = parseInt(limitSel.value, 10) || 10;
      try {
        const [rows, didYouMean] = await Promise.all([
          fetchSearch(query, page, limit),
          fetchTypoSuggest(query)
        ]);
        currentPage = page;
        pageNum.textContent = String(currentPage);
        queryEcho.textContent = `cho \u201C${query}\u201D`;
        renderResults(rows);
        resultsWrap.style.display = 'block';
        // Điều kiện phân trang: nếu ít hơn limit thì ẩn nút Sau
        nextBtn.disabled = rows.length < limit;
        prevBtn.disabled = currentPage <= 1;

        // Render Did you mean
        if (didYouMean && didYouMean.toLowerCase() !== query.toLowerCase()) {
          didYouMeanWrap.style.display = 'block';
          didYouMeanWrap.innerHTML = `Gợi ý: Có phải bạn muốn tìm “<a id="dymLink" href="#">${escapeHtml(didYouMean)}</a>”?`;
          const link = document.getElementById('dymLink');
          link?.addEventListener('click', (e) => {
            e.preventDefault();
            q.value = didYouMean;
            doSearch(1);
          });
        } else {
          didYouMeanWrap.style.display = 'none';
          didYouMeanWrap.innerHTML = '';
        }
      } catch (err) {
        console.error('Search error', err);
      }
    }

    function renderResults(rows) {
      results.innerHTML = '';
      rows.forEach((p) => {
        const card = document.createElement('div');
        card.className = 'result-card';
        const title = escapeHtml(p.title || p.name || '');
        const brand = escapeHtml(p.brand?.text || p.brand || '');
        const price = p.selling_price ?? p.price_promotion ?? p.price;
        const img = p.images || p.units?.[0]?.main_image;
        card.innerHTML = `
          <div class="result-content">
            ${img ? `<img class="result-img" src="${img}" alt="${title}" />` : ''}
            <div class="result-main" style="flex:1; min-width:0;">
              <div class="result-title">${title}</div>
              <div class="result-meta">${brand}</div>
              <div class="result-price">${price ? price.toLocaleString('vi-VN') + ' đ' : ''}</div>
            </div>
          </div>
        `;
        results.appendChild(card);
      });
    }

    prevBtn?.addEventListener('click', () => {
      if (currentPage > 1) doSearch(currentPage - 1);
    });
    nextBtn?.addEventListener('click', () => {
      doSearch(currentPage + 1);
    });

    async function fetchTypoSuggest(query) {
      const base = apiBase.value.replace(/\/$/, '');
      const url = `${base}/api/search/typo_suggest?query=${encodeURIComponent(query)}`;
      const headers = {};
      const tk = token.value.trim();
    if (tk) headers['Authorization'] = tk.startsWith('Bearer ') ? tk : `Bearer ${tk}`;
      try {
        const res = await fetch(url, { headers });
        if (!res.ok) return null;
        const json = await res.json();
        // API trả về { data: { did_you_mean, tokens, correctedTokens } }
        return json?.data?.did_you_mean || null;
      } catch {
        return null;
      }
    }

    // Delete with fallbacks and detailed error (try JSON body first for robust backend handling)
    async function deleteCustomPhrase(id) {
      const base = apiBase.value.replace(/\/$/, '');
      const headers = { };
      const tk = token.value.trim();
      if (tk) headers['Authorization'] = tk.startsWith('Bearer ') ? tk : `Bearer ${tk}`;

      const errors = [];
      // Try DELETE with body first
      const headersJson = { ...headers, 'Content-Type': 'application/json' };
      let res = await fetch(`${base}/api/search/custom_phrases`, { method: 'DELETE', headers: headersJson, body: JSON.stringify({ id }) });
      if (res.ok) return true; else errors.push(`body{id} -> ${res.status}` + ' ' + await res.text().catch(()=>''));
      // Then query param
      res = await fetch(`${base}/api/search/custom_phrases?id=${encodeURIComponent(id)}`, { method: 'DELETE', headers });
      if (res.ok) return true; else errors.push(`?id -> ${res.status}` + ' ' + await res.text().catch(()=>''));
      // Try DELETE with path param
      res = await fetch(`${base}/api/search/custom_phrases/${encodeURIComponent(id)}`, { method: 'DELETE', headers });
      if (res.ok) return true; else errors.push(`/:id -> ${res.status}` + ' ' + await res.text().catch(()=>''));
      alert('Xoá thất bại. ID: ' + id + '\n' + errors.join('\n---\n'));
      return false;
    }
  </script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
</body>
</html>
